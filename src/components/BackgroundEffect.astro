---
import { Image } from "astro:assets";
import backgroundImage from "../assets/images/catppuccin_dots_without_dots_1920x1080.png";
---

<div class="bg-container">
    <Image
        src={backgroundImage}
        alt="Background Rings"
        class="static-bg"
        quality="high"
    />
    <canvas id="dotsCanvas"></canvas>
</div>

<style>
    /* ... (Styles remain exactly the same) ... */
    .bg-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: -1;
        background-color: var(--ctp-base);
        overflow: hidden;
    }
    .static-bg {
        width: 100%;
        height: 100%;
        object-fit: cover;
        opacity: 1;
    }
    canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
    }
</style>

<script>
    const canvas = document.getElementById("dotsCanvas") as HTMLCanvasElement;
    const ctx = canvas.getContext("2d");

    const CONFIG = {
        MIN_SIZE: 7,
        MAX_SIZE: 10,
        SPEED: 0.3,
    };

    const DOT_COLORS = [
        "#f38ba8", "#eba0ac", "#f5c2e7", "#cba6f7", 
        "#f9e2af", "#a6e3a1", "#89b4fa", "#74c7ec", "#89b4fa"
    ];

    // Variables to track the "Logical" size (CSS pixels) for physics
    let logicalWidth = 0;
    let logicalHeight = 0;

    let dots: Dot[] = [];

    class Dot {
        x: number;
        y: number;
        vx: number;
        vy: number;
        radius: number;
        color: string;
        mass: number;

        constructor(color: string) {
            this.color = color;
            this.radius = Math.random() * (CONFIG.MAX_SIZE - CONFIG.MIN_SIZE) + CONFIG.MIN_SIZE;
            this.mass = this.radius;

            // Use logicalWidth/Height for placement
            let overlapping = true;
            while(overlapping) {
                this.x = Math.random() * (logicalWidth - this.radius * 2) + this.radius;
                this.y = Math.random() * (logicalHeight - this.radius * 2) + this.radius;
                overlapping = false;

                for(let other of dots) {
                    const dx = this.x - other.x;
                    const dy = this.y - other.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < this.radius + other.radius) {
                        overlapping = true;
                        break;
                    }
                }
            }

            this.vx = (Math.random() - 0.5) * CONFIG.SPEED; 
            this.vy = (Math.random() - 0.5) * CONFIG.SPEED;
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;

            // Bounce off Walls using LOGICAL dimensions
            if (this.x + this.radius > logicalWidth) {
                this.x = logicalWidth - this.radius;
                this.vx = -this.vx;
            } else if (this.x - this.radius < 0) {
                this.x = this.radius;
                this.vx = -this.vx;
            }

            if (this.y + this.radius > logicalHeight) {
                this.y = logicalHeight - this.radius;
                this.vy = -this.vy;
            } else if (this.y - this.radius < 0) {
                this.y = this.radius;
                this.vy = -this.vy;
            }
        }

        draw() {
            if (!ctx) return;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.closePath();
        }
    }

    function checkCollisions() {
        for (let i = 0; i < dots.length; i++) {
            for (let j = i + 1; j < dots.length; j++) {
                const dot1 = dots[i];
                const dot2 = dots[j];

                const dx = dot2.x - dot1.x;
                const dy = dot2.y - dot1.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < dot1.radius + dot2.radius) {
                    const overlap = (dot1.radius + dot2.radius - distance) / 2;
                    const offsetX = (dx / distance) * overlap;
                    const offsetY = (dy / distance) * overlap;

                    dot1.x -= offsetX;
                    dot1.y -= offsetY;
                    dot2.x += offsetX;
                    dot2.y += offsetY;

                    const nx = dx / distance;
                    const ny = dy / distance;
                    const dvx = dot2.vx - dot1.vx;
                    const dvy = dot2.vy - dot1.vy;
                    const dp = dvx * nx + dvy * ny;

                    if (dp > 0) continue;

                    const f = (2 * dp) / (dot1.mass + dot2.mass);

                    dot1.vx += f * dot2.mass * nx;
                    dot1.vy += f * dot2.mass * ny;
                    dot2.vx -= f * dot1.mass * nx;
                    dot2.vy -= f * dot1.mass * ny;
                }
            }
        }
    }

    function init() {
        resize(); // Set initial size
        dots = [];
        DOT_COLORS.forEach(color => {
            dots.push(new Dot(color));
        });
        animate();
    }

    function animate() {
        if (!ctx) return;
        // Clear based on logical size
        ctx.clearRect(0, 0, logicalWidth, logicalHeight);
        
        dots.forEach(dot => dot.update());
        checkCollisions();
        dots.forEach(dot => dot.draw());
        
        requestAnimationFrame(animate);
    }

    // ðŸ‘‡ THIS IS THE FIX FOR MOBILE/OVALS
    function resize() {
        // 1. Get the exact visual size of the canvas element from CSS
        const rect = canvas.getBoundingClientRect();
        logicalWidth = rect.width;
        logicalHeight = rect.height;

        // 2. Get the device pixel ratio (e.g., 2 for Retina, 3 for modern phones)
        const dpr = window.devicePixelRatio || 1;

        // 3. Set the internal resolution to match the physical pixels
        canvas.width = logicalWidth * dpr;
        canvas.height = logicalHeight * dpr;

        // 4. Scale the drawing context so we can use logical coordinates
        //    (e.g., drawing at 100,100 actually draws at 200,200 on Retina)
        ctx.scale(dpr, dpr);
    }

    window.addEventListener("resize", resize);
    init();
</script>